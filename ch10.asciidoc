= Programming Bitcoin
:imagesdir: images

[[chapter_networking]]

## Networking

The peer-to-peer network that Bitcoin runs on is what gives it a lot of its robustness. 9400+ nodes are running on the network as of this writing and communicate constantly.

The Bitcoin network is a broadcast network or a gossip network. Every node is constantly announcing different transactions, blocks and peers that it knows about. The protocol is rich and has a lot of features that have been added to it over the years.

The nice thing about the networking protocol is that it is not consensus critical. The same data can be sent from one node to another in some other fashion and the blockchain itself would not be affected.

With that in mind, let's start with the very first message that one node sends to another, the version message.

### Network Messages

Network messages have a particular form that looks like this

image:network1.png[Network Message]

The first four bytes are always the same and are referred to as the *network magic*. Magic bytes are common in network programming as the communication can be spotty and asynchronous. Magic bytes give the receiver a place to start should the communication get interrupted. Magic bytes are also useful to make sure the node is on the right network. You would not want a Bitcoin node to connect to a Litecoin node, for example. Thus, a Litecoin node has a differnt magic. Bitcoin testnet also has a different magic `0b110907` as opposed to the Bitcoin mainnet magic `f9beb4d9` above.

The next 12 bytes define the command, or what the payload actually carries. There are many different payloads, many of which can be seen at https://wiki.bitcoin.it. Note that the command is meant to be human-readable and in fact this message is "version" in ascii with 0-byte padding.

The next 4 bytes determine the length of the payload. As we saw in the transaction and block parsing sections, this is necessary as the field is of variable length. As 2^32^ is about 4 billion, we can have payloads that can be as big as 4 GB. Note the number is interpreted in little-endian, so in our case here, that is 101 bytes.

The next 4 bytes are the checksum. The checksum algorithm is something of an odd choice as it's the first 4 bytes of the double-sha256 of the payload. I say odd, as normally, networking protocol checksums generally are designed to have error-correcting capability and double-sha256 has none. That said, the hash function is common in the rest of the protocol and is thus used here.

The code to handle network messages requires us to create a new class:

[source,python]
----
NETWORK_MAGIC = b'\xf9\xbe\xb4\xd9'
TESTNET_NETWORK_MAGIC = b'\x0b\x11\x09\x07'

class NetworkEnvelope:

    def __init__(self, command, payload, testnet=False):
        self.command = command
        self.payload = payload
	if testnet:
	    self.magic = TESTNET_NETWORK_MAGIC
	else:
	    self.magic = NETWORK_MAGIC

    def __repr__(self):
        return '{}: {}'.format(
            self.command.decode('ascii'),
            self.payload.hex(),
        )
----

#### Exercise {counter:exercise}

Determine what this network message is:

f9beb4d976657261636b000000000000000000005df6e0e2

#### Exercise {counter:exercise}

Write the `parse` and `serialize` methods for `NetworkEnvelope`.

### Parsing the payload

Each command has a separate payload specification. Here is the one for version:

image:network2.png[Version Message]

The fields for version are meant to give enough information for two nodes to be able to be able to communicate.

Version specifies the network protocol version being communicated. Services give information about what services are available to connecting nodes. Timestamp here is 8 bytes (as opposed to 4 bytes in the block header) and is the same unix timestamp in little endian.

IP addresses can be IPv6 or IPv4. If IPv4, the first 12 bytes are `00000000000000000000ffff` and the last 4 bytes are the IP. The port is 2 bytes and in little_endian.

Nonce is a number used only once for reply messages. User Agent identifies the software being run. The latest block helps the other node know which block you are synced up to.

Relay is used for Bloom Filters, which we'll get to in Chapter 12.

Setting some reasonable defaults, our VersionMessage class looks like this:

[source,python]
----
class VersionMessage:


    def __init__(
            self,
            version=70015,
            services=0,
            timestamp=None,
            receiver_services=0,
            receiver_ip=b'\x00\x00\x00\x00',
            receiver_port=8333,
            sender_services=0,
            sender_ip=b'\x00\x00\x00\x00',
            sender_port=8333,
            nonce=None,
            user_agent=b'/programming-bitcoin:0.1/',
            latest_block=0,
            relay=True,
    ):
        self.version = version
        self.services = services
        if timestamp is None:
            self.timestamp = int(time.time())
        else:
            self.timestamp = timestamp
        self.receiver_services = receiver_services
        self.receiver_ip = receiver_ip
        self.receiver_port = receiver_port
        self.sender_services = sender_services
        self.sender_ip = sender_ip
        self.sender_port = sender_port
        if nonce is None:
            self.nonce = int_to_little_endian(randint(0, 2**64), 8)
        else:
            self.nonce = nonce
        self.user_agent = user_agent
        self.latest_block = latest_block
        self.relay = relay
----

#### Exercise {counter:exercise}

Write the `serialize` method for `VersionMessage`.



###

Here is the one for inv:

TODO inv payload spec

The idea is that nodes know how to actually send and receive such payloads wrapped inside a network envelope. A fully functional bitcoin node needs to know what to do with every possible network message.

### Network handshake

The network handshake for two nodes is how node communication is established. It goes something like this:

 * A wants to connect to B and sends the version message.
 * B receives the version message and responds with the verack message and sends its own version message.
 * A receives the version and verack messages and continues communication

Once the handshake is finished, A and B can communicate however they want. Note that there is no authentication here and it's up to the nodes to verify all data that come in themselves. A node sending a bad tx or block, for example, can expect to get banned by other nodes.

### Connecting to the network

Network communication is tricky due to its asynchronous nature. To experiment, we can establish a connection to a random node on the network synchronously, however:

TODO show code

Connecting this way will only really show a little bit of data. Furthermore, we can't send until we've received and can't respond intelligently to more than 1 message at a time. A more robust implementation looks like this

TODO show code

TODO show code to download headers

TODO do exercise to validate each header?